# Regular Expression to AFD Converter and Lexer

This project parses regular expressions, constructs their deterministic finite automata (AFDs), performs lexical analysis over input text, and builds an **SLR parser** that validates the syntactic structure of the tokenized input based on a context-free grammar (CFG).

---

## How to Run

Make sure you're inside the `\T2-Formais\src` directory and run:

```bash
python main.py
```

Python 3.8+ is recommended.

## Input Files
These files must exist before running the program:

1. ./input/example_input_RE.txt – contains regular expression definitions, 
    one per line (e.g., ID: (a|b)*abb#)

2. ./input/example_test_input.txt – the source text to be analyzed by the lexer

3. ./input/example_input_grammar.txt - The context-free grammar (CFG) in the format,
    one production per line (e.g., S ::= A B)

All paths are hardcoded in main.py via global variables:

```
INPUT_RE_FILE = "../example_input_RE.txt"
INPUT_USER_FILE = "../example_test_input.txt"
INPUT_GRAMMAR_FILE = "./input/example_input_grammar.txt"
```

## Output files
The following files are generated automatically:

1. ./output/afd_output_{i}.txt – AFD representation for the i-th regular expression

2. ./output/token_list_output.txt – Token list resulting from lexical analysis of the input source

3. ./output/first_output.txt – FIRST sets for all non-terminals.

4. ./output/follow_output.txt – FOLLOW sets for all non-terminals.

5. ./output/lr0_states.txt – LR(0) items (states) generated by the canonical collection algorithm.

6. ./output/lr0_transitions.txt – State transitions for the LR(0) items.

7. ./output/slr_action_table.txt – ACTION table for the SLR parser.

8. ./output/slr_goto_table.txt – GOTO table for the SLR parser.


Global output file variable in main.py:
```
OUTPUT_TOKEN_LIST_FILE = "../token_list_output.txt"
```

## Process Overview

### Read and Parse Regular Expressions
    Parses each line of example_input_RE.txt into a RegularExpression object.
    No output for this step.

### Convert to Postfix Notation
    Converts each regular expression to postfix.
    No output for this step. (Optional print available in code.)

### Build Syntax Tree
    Constructs a syntax tree from the postfix expression.
    No output for this step. (Optional print available.)

### Compute Tree Properties
    Calculates nullable, firstpos, lastpos, and followpos for the tree.
    No output for this step. (Optional print available.)

### Build AFD
    Converts the syntax tree into a deterministic finite automaton (AFD).
    Output: afd_output_{i}.txt

### Create Union of AFDs
    Unifies all individual AFDs into one.
    No direct output for this. (Optional print available.)

### Run Lexer
    Tokenizes the input source using the unified AFD.
    Output: token_list_output.txt


### Read and Interpret Grammar
    Reads CFG from example_input_grammar.txt.

### Compute FIRST and FOLLOW Sets
    Output:

        first_output.txt

        follow_output.txt

### Build Canonical Collection (LR(0) Items)
    Computes closure and goto for LR(0) items.
    Output:

        lr0_states.txt

        lr0_transitions.txt

### Build SLR Parsing Table
    Creates ACTION and GOTO tables using the canonical collection and FOLLOW sets.
    Output:

        slr_action_table.txt

        slr_goto_table.txt

### Execute Parsing Process
    Runs the parser against the token list (token_list_output.txt).
    Prints on console whether the input is syntactically accepted (Sentence Accepted!) or rejected (Sentence Rejected!).



## Example Inputs

Regular Expressions (example_input_RE.txt)

id: [a-zA-Z]([a-zA-Z] | [0-9])*
num: [1-9]([0-9])* | 0
er1: a?(a | b)+
er2: b?(a | b)+

Source Text (example_test_input.txt)

a1
0
teste2
21
alpha123
3444
a43teste
aa
bbbba
ababab
bbbbb

Grammar (example_input_grammar.txt)

S ::= E
E ::= E + T
E ::= T
T ::= T * F
T ::= F
F ::= ( E )
F ::= id

## Example Output

```
Starting regular expression to AFD conversion...

Parsing regEx 1: id: [a-zA-Z]([a-zA-Z] | [0-9])*

#1. Tokenize and create postfix format for regular expression
#2. Build syntax tree
#3. Computing nullable, firstpos, lastpos, and followpos
#4. Build AFD
File saved: ./output/afd_output_0.txt

...

#5. Union with epsilon transitions
#6. Lexer Analysis
File saved: ./output/token_list_output.txt

#7. Interpret grammar
#8. Calculate FIRST and FOLLOW sets
File saved: ./output/first_output.txt
File saved: ./output/follow_output.txt

#9. Build set of LR(0) items (Closure & Goto)
File saved: ./output/lr0_states.txt
File saved: ./output/lr0_transitions.txt

#10. Build SLR parsing table
File saved: ./output/slr_action_table.txt
File saved: ./output/slr_goto_table.txt

#11. Run SLR parsing
Sentence Accepted!


```